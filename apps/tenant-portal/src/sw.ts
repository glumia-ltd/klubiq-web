/// <reference lib="webworker" />
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare let self: ServiceWorkerGlobalScope;
const CACHE_NAMES = ['api-cache', 'static-resources', 'images'];
// Precache all assets generated by vite
precacheAndRoute(self.__WB_MANIFEST);

// Cache API responses
registerRoute(
    ({ url }) => url.pathname.match(/^\/api\//),
    new NetworkFirst({
      cacheName: 'api-cache',
      plugins: [
        new ExpirationPlugin({
          maxEntries: 100,
          maxAgeSeconds: 72 * 60 * 60, // 72 hours
        }),
        new CacheableResponsePlugin({
          statuses: [0, 200],
        }),
      ],
    })
  );
// Cache static assets
registerRoute(
    ({ request }) => request.destination === 'style' || request.destination === 'script',
    new StaleWhileRevalidate({
      cacheName: 'static-resources',
    })
  );
// Cache images
registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
      cacheName: 'images',
      plugins: [
        new ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        }),
      ],
    })
  );

  // Handle push notifications
  self.addEventListener('push', (event) => {
    if(event.data){
        console.log('Push received', event);
        const data = event.data.json();
        event.waitUntil(self.registration.showNotification(data.title, {
            body: data.body,
            icon: '/icon.png',
            badge: '/klubiq-logo.svg',
            data: {
                url: data.actionLink,
            },
        }));
    }
});
// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    if (event.notification.data?.url) {
      event.waitUntil(
        self.clients.matchAll({ type: 'window' }).then( (clientList) => {
			if (clientList.length > 0) {
				let client = clientList[0];
				for (let i = 0; i < clientList.length; i++) {
					if (clientList[i]?.focused) {
						client = clientList[i];
					}
				}
				return client?.focus();
			}
			return self.clients.openWindow(event.notification.data.url);
		}),
      );
    }
  });

// Handle service worker updates
self.addEventListener('activate', (event) => {
    event.waitUntil(
      Promise.all([
        // Take control of all clients
        self.clients.claim(),
        // Clear old caches
        caches.keys().then((cacheNames) => {
          return Promise.all(
            cacheNames.map((cacheName) => {
              if (!CACHE_NAMES.includes(cacheName)) {
                return caches.delete(cacheName);
              }
            })
          );
        }),
      ])
    );
  });

  // Handle service worker installation
  self.addEventListener('install', (event) => {
	self.skipWaiting();
	event.waitUntil(
		caches.has('api-cache').then((hasCaches) => {
			if (!hasCaches) {
				return caches.open('api-cache');
			}
		})
	);
});
